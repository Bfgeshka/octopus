diff --git a/config.def.h b/config.def.h
index 4ab9a68..6ea816b 100644
--- a/config.def.h
+++ b/config.def.h
@@ -135,10 +135,16 @@ static unsigned int defaultunderline = 7;
  * Internal mouse shortcuts.
  * Beware that overloading Button1 will disable the selection.
  */
-static Mousekey mshortcuts[] = {
+static Mousekey mkeys[] = {
 	/* button               mask            string */
-	{ Button4,              XK_ANY_MOD,     "\031" },
-	{ Button5,              XK_ANY_MOD,     "\005" },
+	{ Button4,              XK_NO_MOD,      "\031" },
+	{ Button5,              XK_NO_MOD,      "\005" },
+};
+
+static MouseShortcut mshortcuts[] = {
+	/* button               mask            function        argument */
+	{ Button4,              ShiftMask,      kscrollup,      { .i = 1 } },
+	{ Button5,              ShiftMask,      kscrolldown,    { .i = 1 } },
 };
 
 /* Internal keyboard shortcuts. */
diff --git a/st.c b/st.c
index 30ea2c3..0528117 100644
--- a/st.c
+++ b/st.c
@@ -322,6 +322,13 @@ typedef union {
 } Arg;
 
 typedef struct {
+	uint b;
+	uint mask;
+	void (*func)(const Arg *);
+	const Arg arg;
+} MouseShortcut;
+
+typedef struct {
 	uint mod;
 	KeySym keysym;
 	void (*func)(const Arg *);
@@ -951,13 +958,14 @@ bpress(XEvent *e)
 {
 	struct timespec now;
 	Mousekey *mk;
+	MouseShortcut *ms;
 
 	if (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forceselmod)) {
 		mousereport(e);
 		return;
 	}
 
-	for (mk = mshortcuts; mk < mshortcuts + LEN(mshortcuts); mk++) {
+	for (mk = mkeys; mk < mkeys + LEN(mkeys); mk++) {
 		if (e->xbutton.button == mk->b
 				&& match(mk->mask, e->xbutton.state)) {
 			ttysend(mk->s, strlen(mk->s));
@@ -965,6 +973,14 @@ bpress(XEvent *e)
 		}
 	}
 
+	for (ms = mshortcuts; ms < mshortcuts + LEN(mshortcuts); ms++) {
+		if (e->xbutton.button == ms->b
+				&& match(ms->mask, e->xbutton.state)) {
+			ms->func(&ms->arg);
+			return;
+		}
+	}
+
 	if (e->xbutton.button == Button1) {
 		clock_gettime(CLOCK_MONOTONIC, &now);
 
