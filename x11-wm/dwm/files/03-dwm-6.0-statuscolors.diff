diff -rc3 a/dwm.c b/dwm.c
*** a/dwm.c	2013-08-15 12:57:17.820000000 +0400
--- b/dwm.c	2013-08-15 13:23:19.960000000 +0400
***************
*** 57,62 ****
--- 57,63 ----
  #ifndef MIN
  #define MIN(A, B)               ((A) < (B) ? (A) : (B))
  #endif
+ #define MAXCOLORS               21
  #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
  #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
  #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
***************
*** 112,119 ****
  	Drawable drawable;
  	GC gc;
  
! 	XftColor  xftnorm[ColLast];
! 	XftColor  xftsel[ColLast];
  	XftDraw  *xftdrawable;
  
  	PangoContext *pgc;
--- 113,119 ----
  	Drawable drawable;
  	GC gc;
  
! 	XftColor  colors[MAXCOLORS][ColLast];
  	XftDraw  *xftdrawable;
  
  	PangoContext *pgc;
***************
*** 203,217 ****
  static Monitor *dirtomon(int dir);
  static void drawbar(Monitor *m);
  static void drawbars(void);
! static void drawsquare(Bool filled, Bool empty, Bool invert, unsigned long col[ColLast]);
! static void drawtext(const char *text, unsigned long col[ColLast], Bool invert);
  static void enternotify(XEvent *e);
  static void expose(XEvent *e);
  static void focus(Client *c);
  static void focusin(XEvent *e);
  static void focusmon(const Arg *arg);
  static void focusstack(const Arg *arg);
! //static unsigned long getcolor(const char *colstr);
  static Bool getrootptr(int *x, int *y);
  static long getstate(Window w);
  static Bool gettextprop(Window w, Atom atom, char *text, unsigned int size);
--- 203,218 ----
  static Monitor *dirtomon(int dir);
  static void drawbar(Monitor *m);
  static void drawbars(void);
! static void drawcoloredtext(char *text);
! static void drawsquare(Bool filled, Bool empty, XftColor col[ColLast]);
! static void drawtext(const char *text, XftColor col[ColLast], Bool pad);
  static void enternotify(XEvent *e);
  static void expose(XEvent *e);
  static void focus(Client *c);
  static void focusin(XEvent *e);
  static void focusmon(const Arg *arg);
  static void focusstack(const Arg *arg);
! static XftColor getcolor(const char *colstr);
  static Bool getrootptr(int *x, int *y);
  static long getstate(Window w);
  static Bool gettextprop(Window w, Atom atom, char *text, unsigned int size);
***************
*** 758,764 ****
  drawbar(Monitor *m) {
  	int x;
  	unsigned int i, occ = 0, urg = 0;
! 	unsigned long *col;
  	Client *c;
  
  	for(c = m->clients; c; c = c->next) {
--- 759,765 ----
  drawbar(Monitor *m) {
  	int x;
  	unsigned int i, occ = 0, urg = 0;
! 	XftColor *col;
  	Client *c;
  
  	for(c = m->clients; c; c = c->next) {
***************
*** 769,804 ****
  	dc.x = 0;
  	for(i = 0; i < LENGTH(tags); i++) {
  		dc.w = TEXTW(tags[i].name);
! 		col = m->tagset[m->seltags] & 1 << i ? dc.sel : dc.norm;
! 		drawtext(tags[i].name, col, urg & 1 << i);
! 		drawsquare(m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
! 		           occ & 1 << i, urg & 1 << i, col);
  		dc.x += dc.w;
  	}
  	dc.w = blw = TEXTW(m->ltsymbol);
! 	drawtext(m->ltsymbol, dc.norm, False);
  	dc.x += dc.w;
  	x = dc.x;
  	if(m == selmon) { /* status is only drawn on selected monitor */
! 		dc.w = TEXTW(stext);
  		dc.x = m->ww - dc.w;
  		if(dc.x < x) {
  			dc.x = x;
  			dc.w = m->ww - x;
  		}
! 		drawtext(stext, dc.norm, False);
  	}
  	else
  		dc.x = m->ww;
  	if((dc.w = dc.x - x) > bh) {
  		dc.x = x;
  		if(m->sel) {
! 			col = m == selmon ? dc.sel : dc.norm;
! 			drawtext(m->sel->name, col, False);
! 			drawsquare(m->sel->isfixed, m->sel->isfloating, False, col);
  		}
  		else
! 			drawtext(NULL, dc.norm, False);
  	}
  	XCopyArea(dpy, dc.drawable, m->barwin, dc.gc, 0, 0, m->ww, bh, 0, 0);
  	XSync(dpy, False);
--- 770,804 ----
  	dc.x = 0;
  	for(i = 0; i < LENGTH(tags); i++) {
  		dc.w = TEXTW(tags[i].name);
! 		col = dc.colors[(m->tagset[m->seltags] & 1 << i) ? 1 : (urg & 1 << i ? 2 : 0)];
! 		drawtext(tags[i].name, col, True);
! 		drawsquare(m == selmon && selmon->sel && selmon->sel->tags & 1 << i, occ & 1 << i, col);
  		dc.x += dc.w;
  	}
  	dc.w = blw = TEXTW(m->ltsymbol);
! 	drawtext(m->ltsymbol, dc.colors[0], False);
  	dc.x += dc.w;
  	x = dc.x;
  	if(m == selmon) { /* status is only drawn on selected monitor */
! 		dc.w = textnw(stext, strlen(stext));
  		dc.x = m->ww - dc.w;
  		if(dc.x < x) {
  			dc.x = x;
  			dc.w = m->ww - x;
  		}
! 		drawcoloredtext(stext);
  	}
  	else
  		dc.x = m->ww;
  	if((dc.w = dc.x - x) > bh) {
  		dc.x = x;
  		if(m->sel) {
! 			col = dc.colors[m == selmon ? 1 : 0];
! 			drawtext(m->sel->name, col, True);
! 			drawsquare(m->sel->isfixed, m->sel->isfloating, col);
  		}
  		else
! 			drawtext(NULL, dc.colors[0], False);
  	}
  	XCopyArea(dpy, dc.drawable, m->barwin, dc.gc, 0, 0, m->ww, bh, 0, 0);
  	XSync(dpy, False);
***************
*** 813,822 ****
  }
  
  void
! drawsquare(Bool filled, Bool empty, Bool invert, unsigned long col[ColLast]) {
  	int x;
  
! 	XSetForeground(dpy, dc.gc, col[invert ? ColBG : ColFG]);
  	x = (dc.font.ascent + dc.font.descent + 2) / 4;
  	if(filled)
  		XFillRectangle(dpy, dc.drawable, dc.gc, dc.x+1, dc.y+1, x+1, x+1);
--- 813,847 ----
  }
  
  void
! drawcoloredtext(char *text) {
!   char *buf = text, *ptr = buf, c = 1;
!   XftColor *col = dc.colors[0];
!   int i, ox = dc.x;
! 
!   while(*ptr) {
!     for(i = 0; *ptr < 0 || *ptr > NUMCOLORS; i++, ptr++);
!     if(!*ptr)
!       break;
!     c = *ptr;
!     *ptr = 0;
!     if(i) {
!       dc.w = selmon->ww - dc.x;
!       drawtext(buf, col, False);
!       dc.x += textnw(buf, i);
!     }
!     *ptr = c;
!     col = dc.colors[c-1];
!     buf = ++ptr;
!   }
!   drawtext(buf, col, False);
!   dc.x = ox;
! }
! 
! void
! drawsquare(Bool filled, Bool empty, XftColor col[ColLast]) {
  	int x;
  
! 	XSetForeground(dpy, dc.gc, col[ColFG].pixel);
  	x = (dc.font.ascent + dc.font.descent + 2) / 4;
  	if(filled)
  		XFillRectangle(dpy, dc.drawable, dc.gc, dc.x+1, dc.y+1, x+1, x+1);
***************
*** 825,841 ****
  }
  
  void
! drawtext(const char *text, unsigned long col[ColLast], Bool invert) {
  	char buf[256];
  	int i, x, y, h, len, olen;
  
! 	XSetForeground(dpy, dc.gc, col[invert ? ColFG : ColBG]);
  	XFillRectangle(dpy, dc.drawable, dc.gc, dc.x, dc.y, dc.w, dc.h);
  	if(!text)
  		return;
  	olen = strlen(text);
! 	h = dc.font.ascent + dc.font.descent;
! 	y = dc.y;
  	x = dc.x + (h / 2);
  	/* shorten text if necessary */
  	for(len = MIN(olen, sizeof buf); len && textnw(text, len) > dc.w - h; len--);
--- 850,866 ----
  }
  
  void
! drawtext(const char *text, XftColor col[ColLast], Bool pad) {
  	char buf[256];
  	int i, x, y, h, len, olen;
  
! 	XSetForeground(dpy, dc.gc, col[ColBG].pixel);
  	XFillRectangle(dpy, dc.drawable, dc.gc, dc.x, dc.y, dc.w, dc.h);
  	if(!text)
  		return;
  	olen = strlen(text);
! 	h = pad ? (dc.font.ascent + dc.font.descent) : 0;
! 	y = dc.y + ((dc.h + dc.font.ascent - dc.font.descent) / 2);
  	x = dc.x + (h / 2);
  	/* shorten text if necessary */
  	for(len = MIN(olen, sizeof buf); len && textnw(text, len) > dc.w - h; len--);
***************
*** 845,851 ****
  	if(len < olen)
  		for(i = len; i && i > len - 3; buf[--i] = '.');
  	pango_layout_set_text(dc.plo, text, len);
! 	pango_xft_render_layout(dc.xftdrawable, (col==dc.norm?dc.xftnorm:dc.xftsel)+(invert?ColBG:ColFG), dc.plo, x * PANGO_SCALE, y * PANGO_SCALE);
  }
  
  void
--- 870,876 ----
  	if(len < olen)
  		for(i = len; i && i > len - 3; buf[--i] = '.');
  	pango_layout_set_text(dc.plo, text, len);
! 	pango_xft_render_layout(dc.xftdrawable, col + ColFG, dc.plo, x * PANGO_SCALE, y * PANGO_SCALE);
  }
  
  void
***************
*** 891,897 ****
  		detachstack(c);
  		attachstack(c);
  		grabbuttons(c, True);
! 		XSetWindowBorder(dpy, c->win, dc.sel[ColBorder]);
  		setfocus(c);
  	}
  	else
--- 916,922 ----
  		detachstack(c);
  		attachstack(c);
  		grabbuttons(c, True);
! 		XSetWindowBorder(dpy, c->win, dc.colors[1][ColBorder].pixel);
  		setfocus(c);
  	}
  	else
***************
*** 962,975 ****
  	return atom;
  }
  
! unsigned long
! getcolor(const char *colstr, XftColor *color) {
  	Colormap cmap = DefaultColormap(dpy, screen);
  	Visual *vis = DefaultVisual(dpy, screen);
  
! 	if(!XftColorAllocName(dpy,vis,cmap,colstr, color))
  		die("error, cannot allocate color '%s'\n", colstr);
! 	return color->pixel;
  }
  
  Bool
--- 987,1001 ----
  	return atom;
  }
  
! XftColor
! getcolor(const char *colstr) {
  	Colormap cmap = DefaultColormap(dpy, screen);
  	Visual *vis = DefaultVisual(dpy, screen);
+   XftColor color;
  
! 	if(!XftColorAllocName(dpy,vis,cmap,colstr, &color))
  		die("error, cannot allocate color '%s'\n", colstr);
! 	return color;
  }
  
  Bool
***************
*** 1164,1170 ****
  
  	wc.border_width = c->bw;
  	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
! 	XSetWindowBorder(dpy, w, dc.norm[ColBorder]);
  	configure(c); /* propagates border_width, if size doesn't change */
  	updatewindowtype(c);
  	updatesizehints(c);
--- 1190,1196 ----
  
  	wc.border_width = c->bw;
  	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
! 	XSetWindowBorder(dpy, w, dc.colors[0][ColBorder].pixel);
  	configure(c); /* propagates border_width, if size doesn't change */
  	updatewindowtype(c);
  	updatesizehints(c);
***************
*** 1633,1644 ****
  	cursor[CurMove] = XCreateFontCursor(dpy, XC_fleur);
  
  	/* init appearance */
!         dc.norm[ColBorder] = getcolor(normbordercolor, dc.xftnorm+ColBorder);
!         dc.norm[ColBG] = getcolor(normbgcolor, dc.xftnorm+ColBG);
!         dc.norm[ColFG] = getcolor(normfgcolor, dc.xftnorm+ColFG);
!         dc.sel[ColBorder] = getcolor(selbordercolor, dc.xftsel+ColBorder);
!         dc.sel[ColBG] = getcolor(selbgcolor, dc.xftsel+ColBG);
!         dc.sel[ColFG] = getcolor(selfgcolor, dc.xftsel+ColFG);
  
  	dc.drawable = XCreatePixmap(dpy, root, DisplayWidth(dpy, screen), bh, DefaultDepth(dpy, screen));
  	dc.gc = XCreateGC(dpy, root, 0, NULL);
--- 1659,1669 ----
  	cursor[CurMove] = XCreateFontCursor(dpy, XC_fleur);
  
  	/* init appearance */
!   for(int i = 0; i < NUMCOLORS; i++) {
!     dc.colors[i][ColBorder] = getcolor(colors[i][ColBorder]);
!     dc.colors[i][ColFG] = getcolor(colors[i][ColFG]);
!     dc.colors[i][ColBG] = getcolor(colors[i][ColBG]);
!   }
  
  	dc.drawable = XCreatePixmap(dpy, root, DisplayWidth(dpy, screen), bh, DefaultDepth(dpy, screen));
  	dc.gc = XCreateGC(dpy, root, 0, NULL);
***************
*** 1717,1724 ****
  
  int
  textnw(const char *text, unsigned int len) {
  	PangoRectangle r;
! 	pango_layout_set_text(dc.plo, text, len);
  	pango_layout_get_extents(dc.plo, &r, 0);
  	return r.width / PANGO_SCALE;
  }
--- 1742,1766 ----
  
  int
  textnw(const char *text, unsigned int len) {
+   // remove non-printing color codes before calculating width
+   char *ptr = (char *)text;
+   unsigned int i, ibuf, lenbuf = len;
+   char buf[len+1];
+ 
+   for(i = 0, ibuf = 0; *ptr && i < len; i++, ptr++) {
+     if(*ptr <= NUMCOLORS && *ptr > 0) {
+       if(i < len)
+         lenbuf--;
+     }
+     else {
+       buf[ibuf] = *ptr;
+       ibuf++;
+     }
+   }
+   buf[ibuf] = 0;
+ 
  	PangoRectangle r;
! 	pango_layout_set_text(dc.plo, buf, len);
  	pango_layout_get_extents(dc.plo, &r, 0);
  	return r.width / PANGO_SCALE;
  }
***************
*** 1809,1815 ****
  	if(!c)
  		return;
  	grabbuttons(c, False);
! 	XSetWindowBorder(dpy, c->win, dc.norm[ColBorder]);
  	if(setfocus)
  		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
  }
--- 1851,1857 ----
  	if(!c)
  		return;
  	grabbuttons(c, False);
! 	XSetWindowBorder(dpy, c->win, dc.colors[0][ColBorder].pixel);
  	if(setfocus)
  		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
  }
***************
*** 2064,2071 ****
  			wmh->flags &= ~XUrgencyHint;
  			XSetWMHints(dpy, c->win, wmh);
  		}
! 		else
  			c->isurgent = (wmh->flags & XUrgencyHint) ? True : False;
  		if(wmh->flags & InputHint)
  			c->neverfocus = !wmh->input;
  		else
--- 2106,2116 ----
  			wmh->flags &= ~XUrgencyHint;
  			XSetWMHints(dpy, c->win, wmh);
  		}
! 		else {
  			c->isurgent = (wmh->flags & XUrgencyHint) ? True : False;
+ 			if(c->isurgent)
+ 				XSetWindowBorder(dpy, c->win, dc.colors[2][ColBorder].pixel);
+ 		}
  		if(wmh->flags & InputHint)
  			c->neverfocus = !wmh->input;
  		else
