diff --git a/config.def.h b/config.def.h
index 875885b..c58fe19 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,6 +1,16 @@
 /* See LICENSE file for copyright and license details. */
 
 /* appearance */
+#define NUMCOLORS 7
+static const unsigned long colors[] = {
+    0x54ebff,   // \x01
+    0xdb6794,   // \x02
+    0xef9c3a,   // \x03
+    0xa4bc74,   // \x04
+    0x99FF99,   // Good \x05
+    0xFF6600,   // Warning \x06
+    0xC63333,   // Caution \x07
+};
 static const char font[]            = "-*-terminus-medium-r-*-*-16-*-*-*-*-*-*-*";
 static const char normbordercolor[] = "#444444";
 static const char normbgcolor[]     = "#222222";
diff --git a/drw.c b/drw.c
index b130405..0811d93 100644
--- a/drw.c
+++ b/drw.c
@@ -7,6 +7,8 @@
 #include "drw.h"
 #include "util.h"
 
+#define TEXTW(X)                (drw_font_getexts_width(drw->font, X, strlen(X)) + drw->font->h)
+
 Drw *
 drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h) {
 	Drw *drw = (Drw *)calloc(1, sizeof(Drw));
@@ -140,6 +142,43 @@ drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int
 }
 
 void
+drw_colored_st(Drw *drw, int x, int y, unsigned int w, unsigned int h, char text[][256], const unsigned long *color, const char *ptext) {
+  char buf[256];
+  int i, tx, ty, th, len, olen;
+  Extnts tex;
+
+  if(!drw || !drw->scheme)
+    return;
+  XSetForeground(drw->dpy, drw->gc, drw->scheme->bg->pix);
+  XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+  if(!text || !drw->font)
+    return;
+  olen = strlen(ptext);
+  drw_font_getexts(drw->font, ptext, olen, &tex);
+  th = drw->font->ascent + drw->font->descent;
+  ty = y + (h / 2) - (th / 2) + drw->font->ascent;
+  tx = x + (h / 2);
+  /* shorten text if necessary */
+  for(len = MIN(olen, sizeof buf); len && (tex.w > w - tex.h || w < tex.h); len--)
+    drw_font_getexts(drw->font, ptext, len, &tex);
+  if(!len)
+    return;
+  memcpy(buf, ptext, len);
+  if(len < olen)
+    for(i = len; i && i > len - 3; buf[--i] = '.');
+
+  for (int k = 0; color[k]; k++) {
+    XSetForeground(drw->dpy, drw->gc, color[k]);
+    if (drw->font->xfont)
+      XmbDrawString(drw->dpy, drw->drawable, drw->font->xfont, drw->gc, tx, ty,
+                    text[k], strlen(text[k]));
+    else
+      XDrawString(drw->dpy, drw->drawable, drw->gc, tx, ty, text[k], strlen(text[k]));
+    tx += TEXTW(text[k]) - TEXTW("\x0");
+  }
+}
+
+void
 drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int invert) {
 	char buf[256];
 	int i, tx, ty, th, len, olen;
diff --git a/drw.h b/drw.h
index a5f34e0..043893f 100644
--- a/drw.h
+++ b/drw.h
@@ -64,6 +64,7 @@ void drw_setscheme(Drw *drw, ClrScheme *scheme);
 /* Drawing functions */
 void drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int empty, int invert);
 void drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int invert);
+void drw_colored_st(Drw *drw, int x, int y, unsigned int w, unsigned int h, char text[][256], const unsigned long *color, const char *ptext);
 
 /* Map functions */
 void drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h);
diff --git a/dwm.c b/dwm.c
index ffc8864..e704c6e 100644
--- a/dwm.c
+++ b/dwm.c
@@ -232,6 +232,7 @@ static int xerror(Display *dpy, XErrorEvent *ee);
 static int xerrordummy(Display *dpy, XErrorEvent *ee);
 static int xerrorstart(Display *dpy, XErrorEvent *ee);
 static void zoom(const Arg *arg);
+static void parsestatus(char *text, unsigned long *color_queue, char tokens[][256]);
 
 /* variables */
 static Client *prevclient = NULL;
@@ -266,6 +267,8 @@ static Drw *drw;
 static Fnt *fnt;
 static Monitor *mons, *selmon;
 static Window root;
+static unsigned long color_queue[50];
+static char tokens[256][256];
 
 /* configuration, allows nested code to access above variables */
 #include "config.h"
@@ -691,6 +694,47 @@ dirtomon(int dir) {
 }
 
 void
+parsestatus(char *text, unsigned long *color_queue, char tokens[][256]) {
+
+  char delim[NUMCOLORS+1];
+
+  /* Thanks to http://stackoverflow.com/a/24931903/1612432 */
+  for (int i = 0; i < NUMCOLORS; ++i)
+      delim[i] = i + 1;
+  /* Terminates as string */
+  delim[NUMCOLORS] = '\0';
+
+  char *copy = strdup(text);
+  char *res = strtok(copy, delim);
+  if (!text[res - copy + strlen(res)]){
+    // Status already parsed
+    return;
+  }
+
+  char cleanBuf[strlen(text)];
+  cleanBuf[0] = '\0';
+  strcpy(tokens[0], res);
+  strcat(cleanBuf, res);
+  int i = 1;
+
+  while (res) {
+    /* Figure out what delimiter was used */
+    // Thanks to http://stackoverflow.com/a/12460511/1612432
+    int deli = text[res - copy + strlen(res)] - 1;
+    color_queue[i-1] = colors[deli];
+    res = strtok(0, delim);
+    if (res){
+      strcpy(tokens[i++], res);
+      strcat(cleanBuf, res);
+    }
+  }
+  free(copy);
+  strncpy(text, cleanBuf, strlen(cleanBuf));
+  text[strlen(cleanBuf)] = '\0';
+  color_queue[i] = '\0';
+}
+
+void
 drawbar(Monitor *m) {
 	int x, xx, w;
 	unsigned int i, occ = 0, urg = 0;
@@ -716,13 +760,15 @@ drawbar(Monitor *m) {
 	x += w;
 	xx = x;
 	if(m == selmon) { /* status is only drawn on selected monitor */
+	  parsestatus(stext, color_queue, tokens);
 		w = TEXTW(stext);
 		x = m->ww - w;
 		if(x < xx) {
 			x = xx;
 			w = m->ww - xx;
 		}
-		drw_text(drw, x, 0, w, bh, stext, 0);
+		drw_colored_st(drw, x, 0, w, bh, tokens, color_queue, stext);
+
 	}
 	else
 		x = m->ww;
